# 小程序开发 开发日记

## 开发注意点

微信颜色展示用十六进制编码，rgb不适用。

## 12.25

### 【日志】

​		今天是我实习的第一天，我主要了解微信小程序的基本构成，并复习相关的前端知识。首先，我对小程序的文件结构和工作原理进行了初步的学习。微信小程序是一个基于微信平台的应用程序，它与传统的Web应用程序不同，使用了自己的框架和生态系统。微信小程序由三个核心组成部分组成：WXML（微信标记语言）、WXSS（微信样式表）和JavaScript：WXML用于描述小程序的结构，类似于HTML，但也有其特有的标签和属性；WXSS是用于页面样式的，类似于CSS，且支持部分扩展功能，如尺寸单位“rpx”（响应式像素），有助于适配不同屏幕尺寸。JavaScript主要负责处理页面的逻辑和交互。

​		我还复习了前端开发中的一些基础知识，包括JavaScript、Vue、HTML和CSS。这些知识在开发小程序时是非常有用的。JavaScript的基本语法、变量、函数等基本概念都重新温习了一遍，特别是在函数和事件处理方面，我做了一些简单的练习。Vue的基础概念也简单回顾了一下，因为它与小程序的开发逻辑有一些相似之处，特别是在组件化和数据绑定方面。

​		在复习完相关知识后，我动手编写了第一个微信小程序——“HelloWorld”。通过这个简单的练习，我基本理解了小程序的文件结构和如何通过WXML来构建页面，如何在JavaScript中定义逻辑以及如何通过WXSS来设置样式。同时，我搞清楚了微信用户的登录过程。整个过程虽然简单，但通过实际操作，我对小程序的开发框架有了更直观的理解。

​		今天的学习为后续的小程序开发打下了坚实的基础。我计划在接下来的日子里逐步掌握更多的技术细节，并尝试开发更复杂的小程序功能。总的来说，今天是一个非常充实的学习日，希望明天能继续积累更多的实践经验。

### 微信小程序基本构成

```微信小程序格式
pages //存放页面的文件夹
    index //首页
    --index.js //首页的业务逻辑
    ---index.json //首页的配置
    ---index.wxml //首页的模板
    ---index.wxss //首页的样式
	logs日志页面

utils //工具
--util.js//工具

.eslintrc.js //语法检测配置

app.js //小程序的入口js
app.json //小程序的配置
app.wxss //小程序全局样式
project.confg.json //项目的配置
project.private.config.json //个人项目配置
sitemap.json //站点地图(告诉微信搜索那些页面可以被收录)
```





## 12.26

### 【日志】

今天是实习的第二天，最大的收获是编写了一个简单的聊天界面，并复习了WebSocket的基本通信原理。此外，我还使用Node.js编写了一个本地服务端，实现了客户端和服务端的基础通信。

首先，我着手实现了一个简单的聊天界面。在这个界面中，我添加了发送文本、语音和图片消息的功能。通过使用微信小程序的WXML和WXSS，我构建了聊天框的布局，并设计了不同类型消息的显示方式。文本消息通过常规的输入框进行输入并发送；语音消息通过录音功能来发送，图片消息则允许用户选择图片并发送。为了让界面更加友好，我还通过WXSS定制了消息气泡的样式，使其与常见的聊天应用界面相似。

在完成前端部分后，我开始复习WebSocket的通信原理。WebSocket是一种在客户端和服务器之间建立持久连接的通信协议，允许双向数据交换。它解决了传统HTTP协议中请求-响应模式的限制，适用于实时通信场景。在WebSocket连接建立后，客户端和服务端都可以随时向对方发送消息。这种双向通信非常适合聊天类应用。今天我重点复习了WebSocket的建立连接、消息发送和接收过程，以及如何处理连接的关闭。

接着，我使用Node.js编写了一个简单的WebSocket服务端。通过ws库，我成功实现了一个本地WebSocket服务器，能够接收来自客户端的消息，并将其广播给所有已连接的客户端。在这个过程中，我学到了如何在Node.js中设置WebSocket服务端，如何处理连接事件和消息事件，以及如何管理多个客户端连接。

通过今天的实践，我对WebSocket的使用有了更深入的理解，并且通过编写服务端代码，增强了自己的编程能力。虽然今天的工作量相对较大，但通过动手实现聊天界面和服务端，我更清晰地掌握了如何在实际项目中使用WebSocket实现实时通讯。

明天我计划继续完善聊天界面，并尝试加入其他功能，同时进一步优化服务端的性能和稳定性。

### websocket通讯

#### socket本地服务器搭建

```websocket-server.js
// GPT所生成服务器
// 引入ws库
const WebSocket = require("ws");

// 创建一个WebSocket服务器，监听8000端口
const wss = new WebSocket.Server({ port: 8000 });

// 当客户端连接时
wss.on("connection", (ws) => {
    console.log("客户端已连接");

    // 当接收到客户端的消息时
    ws.on("message", (message) => {
        console.log("收到消息: %s", message);

        // 将收到的消息发送回客户端
        ws.send(`服务器: 收到消息，内容是 ${message}`);
    });

    // 当连接关闭时
    ws.on("close", () => {
        console.log("客户端已断开连接");
    });


});

console.log("WebSocket服务器正在监听8000端口...");
```

#### socket本地服务器搭建（备用）

```server.js
var ws = require("nodejs-websocket")

// Scream server example: "hi" -> "HI!!!"
//创建一个server
var server = ws.createServer(function (conn) {
    console.log("New connection")
    conn.on("text", function (str) {
        // console.log("Received "+str)
        // conn.sendText(str.toUpperCase()+"!!!")
        //链接成功之后，发送欢迎语
        console.log("连接成功")
        //欢迎语
        if(str == 'null'){
            conn.sendText("有什么能帮到您？");
        }
        //输入文字
        else if(str != 'null' && str){
            conn.sendText("文字")
        }
        //输入多媒体
        else{
            conn.sendText("多媒体文本")
        }
        console.log(str);
    })
    conn.on("close", function (code, reason) {
        console.log("Connection closed")
    })
}).listen(8000)
```





## 12.27

### 【日志】

​		今天是实习的第三天，我继续完善小程序的结构，编写了一个index页面作为主页面，并新增了几个子页面：talk（通信）、variety（商品选购）和info（我的个人信息）页面，同时留了demo1和demo2两个备用界面，留着用作后续新功能开发。整个过程非常不顺利，遇到了相当多的问题，特别是talk页面ui显示不全、主页面中的广告滚动播放功能异常，一度导致我进展停滞了好几天。

​		我根据之前学习的内容，设计并实现了一个index页面，作为整个小程序的主页面。在该页面中，我加入了广告滚动播放功能，本来想展示几个精选商品的广告，后来换成了我和我室友的合影。为了让界面更丰富，我还设置了一些常见的导航按钮，用户可以点击这些按钮跳转到不同的子页面。

​		然后，我开始新增了几个子页面：talk页面用于实现用户与店主（当然就是我啦）之间的实时聊天功能；variety页面用于商品选购，展示了商品信息以及购买选项；info页面则展示了我，即开发者的个人信息。

​		但是，编写小程序的新功能时，我遇到了几个意外的问题：广告无法正常滚动，页面似乎存在布局上的异常。同时，我还发现了聊天的ui界面出现按钮显示不完整的问题。后来我才懂得，这两个其实是同一个的问题源，直到三天后我才找到问题所在，四天后我才给出相应的解决方案：问题的根源在于app.wxss和talk.wxss页面中的样式冲突。具体来说，app.wxss中的.containner样式和talk页面中的一些布局样式发生了冲突，导致了广告滚动的异常表现，同时导致了talk界面的图标显示异常。

​		解决这个问题的过程比较繁琐。知道四天后我通过对app.wxss和talk.wxss文件中的样式进行重写，修改了冲突的样式，确保广告区域的布局不受影响，才并使得talk界面能够正常运行。我将.containner样式中的一些固定高度、边距等属性进行了调整，并增加了一些特定于talk页面所需的样式规则。经过这些修改后，各项功能才能正常使用。

​		今天的工作让我发现了众多问题，尤其是在多页面的项目中，如何避免样式冲突是一个重点。虽然遇到了一些挑战，但是我一直没有放弃希望，相信自己一定能解决这些难题，能够掌握如何优化和管理样式。



## 12.28

### 【日志】

​		今天是实习的第四天，我今儿的打算是学习如何在微信云托管上搭建微信云服务器，并实现一个简单的Express.js服务器。我还进一步学习了Nginx反向代理的相关知识，为将来的开发做了更多准备。有趣的是，最后我的服务器并没有用上express，嘿嘿。

​		我跟着微信官方的教程，学习了如何使用微信云托管服务。这项服务为开发者提供了便捷的云端托管解决方案，可以将小程序的后端服务部署到云端，免去传统服务器的管理和维护工作。通过微信云托管，我能够直接在云端管理应用的服务器，简化了开发和部署流程。

​		在微信云托管上搭建云服务器后，我选择使用了Express.js来创建一个简单的后端服务。Express.js是Node.js环境下非常流行的Web应用框架，具有轻量、灵活的特点，特别适合快速开发RESTfulAPI。我按照教程的指引，成功搭建了一个基本的Express.js服务器，并实现了几个简单的路由和接口，用于处理HTTP请求。

**我的服务器名称：**express-gmz2

**公网访问地址：**https://express-gmz2-133545-9-1333758115.sh.run.tcloudbase.com

**开放端口：**8089

​		在学习微信云托管和Express.js的过程中，我还了解了Nginx的基本使用。Nginx是一款高性能的Web服务器，常用于反向代理和负载均衡。在今天的学习中，我了解了Nginx作为反向代理服务器的工作原理。反向代理的主要作用是将客户端的请求转发到后端服务器进行处理，隐藏后端服务器的真实地址。通过配置Nginx，我能够实现对外的单一入口地址，简化了对不同服务的管理，同时也能提高应用的性能和安全性。

​		今天的学习让我对微信云托管、Express.js和Nginx有了更深入的理解。在这次的项目中，如果我能合理地使用这些工具和技术，将大大提升我的开发效率和系统的稳定性。不过很快我就会发现微信云托管一键部署的弊端，并最终选择自己手写服务器端。

### 微信云托管一键部署（教学熟悉）

#### 官方教程

[快速开始 / 自定义部署 / Python](https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloudrun/src/quickstart/custom/python.html)

#### 云托管服务名称

express-gmz2-001

#### 环境ID

prod-1gq42k846fd37e87

#### 云端数据库

账号：root
密码：nk4PS9zt

#### 域名地址

[express-gmz2](https://express-gmz2-133545-9-1333758115.sh.run.tcloudbase.com)

https://express-gmz2-133545-9-1333758115.sh.run.tcloudbase.com

#### 基本使用

在小程序util.js中按需要使用如下的代码（取代原有wx.request用法）：

```js
// 确认已经在 onLaunch 中调用过 wx.cloud.init 初始化环境（任意环境均可，可以填空）
const res = await wx.cloud.callContainer({
  config: {
    env: '填入云环境ID', // 微信云托管的环境ID
  },
  path: '/xxx', // 填入业务自定义路径和参数，根目录，就是 / 
  method: 'POST', // 按照自己的业务开发，选择对应的方法
  header: {
    'X-WX-SERVICE': 'xxx', // xxx中填入服务名称（微信云托管 - 服务管理 - 服务列表 - 服务名称）
    // 其他header参数
  }
  // dataType:'text', // 默认不填是以JSON形式解析返回结果，若不想让SDK自己解析，可以填text
  // 其余参数同 wx.request
});

console.log(res);
```

如上使用前，需要在小程序app.js中，执行wx.init，如下代码：

```js
App({
  async onLaunch() {
    // 使用callContainer前一定要init一下，全局执行一次即可
    wx.cloud.init()
    // 下面的请求可以在页面任意一处使用
    const result = await wx.cloud.callContainer({
      config: {
        env: 'prod-01', // 微信云托管的环境ID
      },
      path: '/', // 填入业务自定义路径和参数，根目录，就是 / 
      method: 'GET', // 按照自己的业务开发，选择对应的方法
      header: {
        'X-WX-SERVICE': 'xxx', // xxx中填入服务名称（微信云托管 - 服务管理 - 服务列表 - 服务名称）
      }
      // dataType:'text', // 默认不填是以JSON形式解析返回结果，若不想让SDK自己解析，可以填text
    })
    console.log(result)
  }
})
```

以PUT为例，修改后对比代码

```
async function putApi(url, data, successCallback, errCallback, completeCallback) {
  try {
    const res = await wx.cloud.callContainer({
      config: {
        env: '你的云环境ID', // 填入你的微信云环境ID
      },
      path: url, // 填入你需要访问的 API 路径
      method: 'PUT', // 设置 HTTP 请求方法
      header: {
        'Authorization': app.globalData.accessToken, // 设置授权头
        'X-WX-SERVICE': '你的服务名称', // 填入你云托管服务的名称
        // 如果需要其他的header可以继续添加
      },
      data: data, // 请求的参数
    });

    if (res.statusCode === 250 || res.statusCode === 500) {
      if (typeof errCallback === "function") {
        errCallback(res);
      } else {
        wx.showToast({
          title: res.data,
          duration: 2000
        });
      }
    } else {
      if (typeof successCallback === "function") {
        successCallback(res);
      }
    }
  } catch (err) {
    if (typeof errCallback === "function") {
      errCallback(err);
    } else {
      wx.showToast({
        title: '接口调用失败！',
        duration: 2000
      });
    }
  } finally {
    if (typeof completeCallback === "function") {
      completeCallback();
    }
  }
}

```

#### 服务器架设后，微信官方建议所用小程序代码使用格式

```js
wx.cloud.callContainer({
  "config": {
    "env": "prod-1gq42k846fd37e87"
  },
  "path": "/api/count",
  "header": {
    "X-WX-SERVICE": "express-gmz2"
  },
  "method": "POST",
  "data": {
    "action": "inc"
  }
})
```

### 微信云托管自定义部署（13.31补充）

#### 云托管服务名称

websocket-server

#### 容器端口

8000



## 12.29

### 【日志】

今天是实习的第五天，我遇到了来到中软后前所未有的、心理上的挑战。但在老师的鼓励和自我心态调整后，我继续完善了自己小程序的功能，同时也学习了一些新的技术。

在和同学交流时，我得知腾讯已经做过一个IM即时通讯包，瞬间我觉得自己所做的工作微不足道。我已经花费了几天时间开发自己的聊天功能，但突然发现腾讯已经为这类需求提供了一个现成的解决方案。一瞬间我无比沮丧，觉得自己的努力和成果远远不如别人已经做好的东西。这种情绪让我一度陷入了困惑和自我怀疑。

然而，在经过一段时间的思考和老师的鼓励后，我调整好了自己的心态。我意识到，技术的世界充满了大量现成的工具和框架，我们不可能在每一个项目中都做出最完善的解决方案。有时候，借用别人已有的包确实能帮助我们在一定程度上解决问题，但在更个性化的场景中，往往更加受制于人，也因此会遇到企业收费，使自己的项目处于被动状态。与此同时，我也在学习过程中不断积累经验，今天的工作或许不如别人做得好，但这本身就是成长的过程。

接着，我深入了解了腾讯的IM包，学习到了不少技术细节，特别是在消息处理和数据同步方面。虽然它已经为大部分常见需求提供了解决方案，但我也发现了它的一些局限性。它可能不完全适用于所有场景，特别是在一些只可以使用局域网的情况下。这个过程让我认识到，技术的选择是多元的，学习借鉴他人经验的同时，我们也需要根据自己的需求做出合理的取舍。

除了对IM包的学习，今天我还学习了Git的一些基本命令，包括如何创建本地仓库、提交代码、查看历史记录以及如何推送代码到GitHub。我将自己的代码上传到了GitHub上，这样不仅方便自己备份和管理代码，也为日后的协作开发提供了便利。

今天虽然遇到了一些心态上的波动，但我从中学到了很多，尤其是如何调整心态面对挑战，如何借鉴别人的经验，同时保持对自己项目的信心。这两天是我的至暗时刻，我不知道的是，很快，太阳就要出来了。

### 【小程序结构】

```
css
	iconfont.wxss
	weui.wxss
images
	admin.png
pages
	components
		info
		--info.js
    	---info.json
    	---info.wxml
    	---info.wxss
		server
		---server.js
		talk
		--talk.js
    	---talk.json
    	---talk.wxml
    	---talk.wxss
		utils
		util.js
		varity
		--varity.js
    	---varity.json
    	---varity.wxml
    	---varity.wxss
	index
    --index.js
    ---index.json
    ---index.wxml
    ---index.wxss
	logs日志页面
    --logs.js
    ---logs.json
    ---logs.wxml
    ---logs.wxss
server
---server.js
utils
--util.js
.gitignore
app.js
app.json
app.wxss
project.confg.json
project.private.config.json
README.md
```

### git命令

#### 创建仓库

- **git init**：初始化一个git仓库
- **git clone**：clone一个git仓库

#### git基本命令

- **git config**：配置信息
- **git add**：添加文件到缓存命令
- **git status**：查看文件的状态命令
- **git diff**：查看更新的详细信息命令
- **git commit**：提交命令
- **git reset HEAD**：取消缓存命令
- **git rm**：删除命令
- **git mv**：移动或重命名命令

#### Git分支管理

- **git branch**：查看分支命令
- **git branch (branchname)**：创建分支命令
- **git checkout (branchname)**：切换分支命令
- **git merge**：合并分支命令
- **git branch -d (branchname)**：删除分支命令

#### Git查看提交历史

- **git log --oneline** ：查看历史记录的简洁版本
- **git log --graph** ：查看历史中什么时候出现了分支、合并
- **git log --reverse** ：逆向显示所有日志
- **git log --author** ：查找指定用户的提交日志
- **git log --since、git log --before、 git log --until、git log --after**： 指定筛选日期
- **git log --no-merges** ：选项以隐藏合并提交

#### Git 标签

- **git tag**：查看所有便签
- **git tag -a <tagname> -m "某某标签"**：查看指定标签信息

#### Git 远程仓库

- **git remote add**：添加远程仓库
- **git remote**：查看当前的远程仓库
- **git fetch**、**git pull**：提取远程仓仓库
- **git push**：推送到远程仓库
- **git remote rm**：删除远程仓库



## 12.30

### 【日志】

今天是实习的第六天，我在我的小程序中新增了一个新的功能模块——文心一言。通过调用千帆大模型的API，我成功实现了实时对话功能，让用户能够与小程序进行智能对话。

文心一言是基于大语言模型的聊天机器人，通过调用千帆大模型的接口，我在小程序中实现了与机器人的实时对话功能。在实现过程中，我学习了如何进行API请求和处理接口返回的数据，并将其展示在聊天界面中。用户可以输入问题并接收大模型的回答，这为小程序增加了更多的互动性和智能化功能。

今天，我终于看到了开发的曙光：talk页面UI显示不完整的问题。这个问题让我一直困扰了很长时间，今天晚上终于找到了问题的根源：app.wxss中的.containner样式与talk页面发生了冲突。这不仅导致了talk页面布局异常，也影响了主页面的广告图片滚动播放功能。这几天改代码我一直加班到深夜，当我发现这个问题是已经很晚了，我决定把这个问题留到明天解决。

今天的工作虽然遇到了些许问题，但通过添加新的功能模块，我收获了不少技术经验，也进一步加深了对API调用和数据处理的理解。同时，我也意识到UI样式冲突的问题需要更谨慎地管理和调试，避免类似问题影响项目的正常运行。

明天，我将着手解决talk页面和主页面的样式冲突问题，并对文心一言功能进行进一步的优化和测试。



## 12.31

### 【日志】

​		今天是实习的第七天，我完成了一个重要的里程碑！我成功实现了微信云托管服务器的自主部署，并将通信从localhost局域网扩展到了互联网。

​		今天，我发现了一键部署的各种问题。微信云托管一键部署虽然能快速搭建服务器，但它在配置方面相对封闭。例如，云托管服务的配置选项有限，无法像传统的云服务（如AWS、阿里云等）那样提供深度的自定义配置。对于需要特殊定制化、复杂配置的项目，一键部署完全不能满足需求。比如，无法自由地修改服务器环境、安装额外的依赖包。因此，我创建了一个名为websocket-server的服务器，虽然还是使用微信云托管的环境进行部署，但是主程序完全由自己编写。我暴露了8000端口用于WebSocket通信，在此过程中，我不仅深入学习了WebSocket的通信原理，还了解了如何在云端环境中高效管理和部署服务器。与之前只能在局域网内通信相比，现在的小程序可以通过互联网进行实时通信，这标志着功能和技术上的一次飞跃。

​		完成服务器部署后，我对小程序的功能进行了全面完善，并将其发布为1.0.0体验版。这一版本实现了以下核心功能：

**商品种类查看：**用户可以浏览不同类别的商品信息，方便进行商品选择。

**移动端与服务端通信：**实现了移动端通过WebSocket与后端实时交互的功能。

**AI智能助理聊天：**通过调用文心一言，用户可以体验与大模型的实时对话。

**开发者信息查看：**用户能够通过“我的”页面了解小程序开发者的相关信息。

​		在发布体验版之前，我对各个功能进行了详细的测试，以确保用户体验流畅和系统稳定。尽管开发过程中遇到了一些挑战，例如云端部署时的环境配置和端口映射问题、ui界面显示不完整、广告播放异常等等，但通过不断学习和调整，我最终成功解决了这些问题。

​		今天的成果让我感到非常自豪，从最初的局域网通信到如今的互联网通信，再到功能完整的小程序体验版上线，我看到了自己的成长与进步。这些技术和经验将我为后续的开发打下坚实基础。



## 2025.1.1

### 【日志】

​		今天是实习的第八天，我在小程序中新增了三个功能模块：

①团队介绍：这个功能展示了团队成员的基本信息、职责分工以及团队目标，帮助用户了解我们团队的构成和工作重点。

②萨勒芬妮图片展：实际没什么用，单纯因为我喜欢萨勒芬妮这个英雄，所以通过分页和滑动展示的方式展示一下。

③我的室友：这是一个展示我和我的室友照片的功能，用户可以欣赏与我共住四年的大学室友的芳容。

​		新增这些功能后，我对小程序进行了测试，并发现了一个较为严重的配置错误。问题出现在app.json配置文件中，具体来说，是networkTimeout字段的配置问题。原本该字段的值应该是一个数字，但我不小心设置了一个非数字类型的值。这个错误导致了配置文件加载失败，影响了小程序的正常运行。最后，经过一系列的优化和调试，我将这个版本定为1.0.3稳定版，并将其上传到了远端仓库，以确保所有更新能够及时同步。这个版本的稳定性得到了进一步提高，也完善了小程序的功能。

​		今天的工作让我收获了很多，不仅在功能实现上有所进展，还在解决实际问题时提升了我的调试能力。从今天起我应该会暂停了小程序的开发了，我要去帮助团队开发web端的相关内容。

## 1.6

## 【日志】		

今天是实习的第十三天。眼睛一闭一睁，星期一了。我之前的想法应验了，老师问我想不想整个购物车结算功能。您都这么问了，我不想也得想了。今天不弄web了，回到我的老本行小程序了。

​		购物车结算功能使得用户可以在商品选购页面选择自己喜欢的商品，在点击结算后进入购物车页面，进行进一步的结算操作。这个功能的实现意味着小程序从单纯的商品展示功能，向完整的电商系统迈出了重要的一步。购物车结算功能不仅增强了用户的交互体验，还为小程序的商业化奠定了基础。

​		在实现购物车功能时，首先我需要设计好商品选择的逻辑。用户可以从商品列表中选择多个商品，点击商品后，商品信息会被存储到购物车数据中。这些数据包括商品的名称、价格、数量等信息，我花了大量时间调试这个部分，确保商品信息能够正确传递和更新。在结算的部分。一旦用户选择完商品并点击结算按钮，就会跳转到购物车结算页面。在这个页面中，我需要展示选中的商品信息，以及它们的总价。同时，当前购物车中的商品信息将会被导出为一个文件，未来我还计划实现将购物车内容发送到 Web 端的功能。这样用户不仅可以保存购物信息，还能方便地在其他平台上查看。

​		在完成这些主要功能后，我还对主页的广告图片进行了更改。原来的广告图片有些过时，并且与当前小程序的整体风格不太匹配。通过更换新的广告图片，我不仅提升了小程序的视觉效果，还增强了用户的吸引力，提升了用户体验。

​		另一个问题是在购物车数据传输方面，数据没有正确传递到结算页面，导致结算页面显示为空。这让我意识到，我在设计数据传递和状态管理时没有考虑到小程序的数据同步和生命周期管理。

​		今儿的工作又开始多起来了。忙，忙一点好啊。